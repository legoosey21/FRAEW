#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      reece
#
# Created:     10/11/2025
# Copyright:   (c) reece 2025
# Licence:     <your licence>
#-------------------------------------------------------------------------------
#!/usr/bin/env python3
"""
BN1 Pricing Suite — FRAEW + Fire Doors + Compartmentation + Fire Strategy + Safety Case
- Instant quote previews on all tabs (updates as you type)
- Time-limited license keys + HTTPS network time verification
- Consolidated CSV export to Desktop (Capsule-friendly)
"""

import base64, io, math, os, sys, socket, ssl, csv, json
import datetime as _dt
from email.utils import parsedate_to_datetime

import tkinter as tk
from tkinter import ttk, messagebox, filedialog

# ---------- Optional dependencies ----------
try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except Exception:
    PIL_AVAILABLE = False

try:
    import requests
    HAS_REQUESTS = True
except Exception:
    HAS_REQUESTS = False

# ======================= CONFIG =======================
SECRET_SALT = "bn1_pricing_2025_secret_v2"
REQUIRE_NETWORK_TIME = True

TRUSTED_TIME_HOSTS = [
    "https://www.google.com/",
    "https://www.cloudflare.com/",
    "https://www.microsoft.com/",
    "https://www.amazon.co.uk/",
    "https://www.bbc.co.uk/",
]

APP_TITLE = "BN1 Surveyors — Pricing Suite"
WINDOW_SIZE = "1140x760"
EXPORT_CSV = "bn1_pricing_exports.csv"

# ------------------ EMBEDDED LOGO (base64 PNG) ------------------
EMBEDDED_LOGO_B64 = (
    "iVBORw0KGgoAAAANSUhEUgAABaAAAAy0CAYAAADm6pFvAAAACXBIWXMAAAsTAAALEwEAmpwY"
    "AAAgAElEQVR4nOydd3xVdb3/3+3m3s7O7uzk7u7u7s7s7u7s7t7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7"
    "u7u7u7u7u79+Z3XcAAAgAElEQVR4nO3dQY7kKBGYV0r//8f3Y1pG0xg8rF2q5e3c7u7u7u7u7"
    "u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u/8H8D5uF0GgAA"
    "AABJRU5ErkJggg=="
)

# =============== Small helpers ===============
def round_to_nearest_25(value: float) -> float:
    return round(value / 25) * 25

def _get_int(var, default):
    try: return int(var.get())
    except Exception: return default

def _get_float(var, default):
    try: return float(var.get())
    except Exception: return default

def get_desktop_dir():
    """Return the user's Desktop folder (Windows/Mac/Linux), fallback to home."""
    if os.name == "nt":
        try:
            from ctypes import windll, wintypes, create_unicode_buffer
            CSIDL_DESKTOP = 0x0000
            SHGFP_TYPE_CURRENT = 0
            buf = create_unicode_buffer(260)
            if windll.shell32.SHGetFolderPathW(None, CSIDL_DESKTOP, None, SHGFP_TYPE_CURRENT, buf) == 0:
                path = buf.value
                if os.path.isdir(path):
                    return path
        except Exception:
            pass
    home = os.path.expanduser("~")
    desktop = os.path.join(home, "Desktop")
    return desktop if os.path.isdir(desktop) else home

# ============= Network time helpers =============
def _https_head_date(url: str, timeout: float = 5.0):
    try:
        if HAS_REQUESTS:
            r = requests.head(url, timeout=timeout, allow_redirects=True)
            date_hdr = r.headers.get("Date") or r.headers.get("date")
            if not date_hdr:
                return None
            d = parsedate_to_datetime(date_hdr)
            return d.astimezone(_dt.timezone.utc).replace(tzinfo=None)
        else:
            hostname = url.split("://", 1)[1].split("/", 1)[0]
            with socket.create_connection((hostname, 443), timeout=timeout) as sock:
                ctx = ssl.create_default_context()
                with ctx.wrap_socket(sock, server_hostname=hostname) as ssock:
                    ssock.sendall(
                        b"HEAD / HTTP/1.1\r\nHost: " + hostname.encode("utf-8") +
                        b"\r\nConnection: close\r\n\r\n"
                    )
                    data = b""
                    while True:
                        chunk = ssock.recv(4096)
                        if not chunk:
                            break
                        data += chunk
            headers = data.split(b"\r\n\r\n", 1)[0].decode(errors="ignore")
            for line in headers.split("\r\n"):
                if line.lower().startswith("date:"):
                    date_hdr = line.split(":", 1)[1].strip()
                    d = parsedate_to_datetime(date_hdr)
                    return d.astimezone(_dt.timezone.utc).replace(tzinfo=None)
            return None
    except Exception:
        return None

def get_network_utc_datetime(timeout_per_host: float = 5.0):
    results = []
    for url in TRUSTED_TIME_HOSTS:
        d = _https_head_date(url, timeout=timeout_per_host)
        if d:
            results.append(d)
    if not results:
        return None
    ts = sorted([x.timestamp() for x in results])
    median_ts = ts[len(ts) // 2]
    return _dt.datetime.utcfromtimestamp(median_ts)

# ================= Licensing =================
def _license_digest(name: str, expiry_yyyymmdd: str) -> str:
    payload = f"{name}|{expiry_yyyymmdd}|{SECRET_SALT}".encode("utf-8")
    return __import__("hashlib").sha256(payload).hexdigest().upper()

def make_expected_key(name: str, expiry_yyyymmdd: str) -> str:
    h = _license_digest(name, expiry_yyyymmdd)
    return f"BN1-{expiry_yyyymmdd}-{h[:8]}-{h[8:12]}"

def validate_license_key_local(key: str, name: str):
    try:
        key = key.strip().upper()
        if not key.startswith("BN1-"):
            return False, "Key format not recognised.", None
        parts = key.split("-")
        if len(parts) != 4:
            return False, "Key format invalid.", None
        expiry = parts[1]
        exp_date = _dt.datetime.strptime(expiry, "%Y%m%d").date()
        expected = make_expected_key(name, expiry)
        if key != expected:
            return False, "Name / key do not match.", None
        return True, "", exp_date
    except Exception as e:
        return False, f"Validation error: {e}", None

def validate_license_key_with_network_time(key: str, name: str, require_network_time: bool = REQUIRE_NETWORK_TIME):
    ok, reason, exp_date = validate_license_key_local(key, name)
    if not ok:
        return False, reason
    net_dt = get_network_utc_datetime()
    if net_dt is None:
        if require_network_time:
            return False, "Network time required but unavailable. Connect to the internet and try again."
        else:
            today = _dt.date.today()
            if today > exp_date:
                return False, f"License expired on {exp_date.isoformat()} (local time)."
            return True, ""
    net_date = net_dt.date()
    if net_date > exp_date:
        return False, f"License expired on {exp_date.isoformat()} (network date {net_date.isoformat()})."
    return True, ""

# ================= App =================
class BN1PricingApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(APP_TITLE)
        self.geometry(WINDOW_SIZE)
        self.minsize(1000, 660)
        self.configure(bg="#f5f7fa")
        self.logo_img = None

        # storage for last computed rows (so export can gather them)
        self.last_fraew = None
        self.last_doors = None
        self.last_comp = None
        self.last_strategy = None
        self.last_safety = None

        self._setup_styles()
        self._create_widgets()

    # ---------- styles ----------
    def _setup_styles(self):
        self.title_font = ("Segoe UI", 14, "bold")
        self.label_font = ("Segoe UI", 11, "bold")
        self.text_font = ("Segoe UI", 10)
        style = ttk.Style(self)
        try:
            style.theme_use("default")
        except Exception:
            pass
        style.configure("TFrame", background=self["bg"])
        style.configure("TLabel", background=self["bg"])
        style.configure("TButton", padding=6)

    # ---------- main widgets (tabs) ----------
    def _create_widgets(self):
        header = ttk.Frame(self)
        header.pack(fill="x", padx=12, pady=(12, 6))

        # Logo area
        logo_frame = ttk.Frame(header)
        logo_frame.pack(side="left", anchor="nw")

        self.banner_max_w = 300
        self.banner_max_h = 96
        self.logo_canvas = tk.Canvas(
            logo_frame, width=self.banner_max_w, height=self.banner_max_h,
            highlightthickness=0, bg=self["bg"]
        )
        self.logo_canvas.pack()

        # Try embedded logo -> external file -> fallback
        if EMBEDDED_LOGO_B64 and EMBEDDED_LOGO_B64 != "<PASTE_BASE64_HERE>":
            loaded = self._try_load_image_from_base64(EMBEDDED_LOGO_B64)
            if not loaded:
                self._load_logo_if_present()
        else:
            self._load_logo_if_present()

        ttk.Label(header, text="BN1 Pricing Tool", font=self.title_font)\
            .pack(side="left", padx=(12, 6), pady=(6, 0))

        # Export button
        ttk.Button(header, text="Export CSV", command=self.export_consolidated_csv)\
            .pack(side="right", padx=(6, 0), pady=(6, 0))

        # Notebook (tabs)
        notebook = ttk.Notebook(self)
        notebook.pack(fill="both", expand=True, padx=12, pady=6)

        fraew_tab = ttk.Frame(notebook)
        doors_tab = ttk.Frame(notebook)
        comp_tab = ttk.Frame(notebook)
        strategy_tab = ttk.Frame(notebook)
        safety_tab = ttk.Frame(notebook)

        notebook.add(fraew_tab, text="FRAEW")
        notebook.add(doors_tab, text="Fire Doors")
        notebook.add(comp_tab, text="Compartmentation")
        notebook.add(strategy_tab, text="Fire Strategy")
        notebook.add(safety_tab, text="Safety Case")

        # Build tab contents
        self._build_fraew_tab(fraew_tab)
        self._build_fire_doors_tab(doors_tab)
        self._build_compartmentation_tab(comp_tab)
        self._build_fire_strategy_tab(strategy_tab)
        self._build_safety_case_tab(safety_tab)

        # Initial message
        self._write_results(
            "Welcome — live preview is on for all tabs. Click Compute for full breakdown and save/export."
        )

    # ---------- FRAEW tab ----------
    def _build_fraew_tab(self, parent):
        main = ttk.Frame(parent)
        main.pack(fill="both", expand=True)

        form_frame = ttk.Frame(main)
        form_frame.pack(side="left", fill="y", padx=(0, 8), pady=6)

        ttk.Label(form_frame, text="1) Timeframe urgency (1–5; 5 = very urgent):", font=self.label_font).pack(anchor="w")
        self.timeframe_var = tk.IntVar(value=3)
        timeframe_spin = ttk.Spinbox(form_frame, from_=1, to=5, textvariable=self.timeframe_var, width=5, font=self.text_font)
        timeframe_spin.pack(anchor="w", pady=(0, 8))
        timeframe_spin.configure(command=self._fraew_preview)
        timeframe_spin.bind("<KeyRelease>", lambda e: self._fraew_preview())
        self.timeframe_var.trace_add("write", self._fraew_preview)

        ttk.Label(form_frame, text="2) Importance of cost (−5 to +5):", font=self.label_font).pack(anchor="w")
        self.cost_importance_var = tk.IntVar(value=0)
        cost_spin = ttk.Spinbox(form_frame, from_=-5, to=5, textvariable=self.cost_importance_var, width=5, font=self.text_font)
        cost_spin.pack(anchor="w", pady=(0, 8))
        cost_spin.configure(command=self._fraew_preview)
        cost_spin.bind("<KeyRelease>", lambda e: self._fraew_preview())
        self.cost_importance_var.trace_add("write", self._fraew_preview)

        self.ews1_var = tk.BooleanVar(value=False)
        ews1_chk = ttk.Checkbutton(form_frame, text="3) EWS1 form required", variable=self.ews1_var)
        ews1_chk.pack(anchor="w", pady=(0, 8))
        self.ews1_var.trace_add("write", self._fraew_preview)

        self.new_client_var = tk.BooleanVar(value=False)
        new_client_chk = ttk.Checkbutton(form_frame, text="4) New client", variable=self.new_client_var)
        new_client_chk.pack(anchor="w", pady=(0, 8))
        self.new_client_var.trace_add("write", self._fraew_preview)

        self.tri_fire_var = tk.BooleanVar(value=False)
        tri_fire_chk = ttk.Checkbutton(form_frame, text="5) Triggered by Tri-Fire", variable=self.tri_fire_var)
        tri_fire_chk.pack(anchor="w", pady=(0, 8))
        self.tri_fire_var.trace_add("write", self._fraew_preview)

        ttk.Label(form_frame, text="6) Building height (m):", font=self.label_font).pack(anchor="w")
        self.height_var = tk.DoubleVar(value=12.0)
        height_entry = ttk.Entry(form_frame, textvariable=self.height_var, width=10, font=self.text_font)
        height_entry.pack(anchor="w", pady=(0, 8))
        height_entry.bind("<KeyRelease>", lambda e: self._fraew_preview())
        self.height_var.trace_add("write", self._fraew_preview)

        ttk.Label(form_frame, text="7) Difficulty / complexity (1–5):", font=self.label_font).pack(anchor="w")
        self.difficulty_var = tk.IntVar(value=3)
        difficulty_spin = ttk.Spinbox(form_frame, from_=1, to=5, textvariable=self.difficulty_var, width=5, font=self.text_font)
        difficulty_spin.pack(anchor="w", pady=(0, 12))
        difficulty_spin.configure(command=self._fraew_preview)
        difficulty_spin.bind("<KeyRelease>", lambda e: self._fraew_preview())
        self.difficulty_var.trace_add("write", self._fraew_preview)

        btn_frame = ttk.Frame(form_frame)
        btn_frame.pack(fill="x", pady=(6, 0))
        ttk.Button(btn_frame, text="Compute Price", command=self.on_compute).pack(side="left", padx=(0, 6))
        ttk.Button(btn_frame, text="Clear Results", command=self.clear_results).pack(side="left", padx=(0, 6))
        ttk.Button(btn_frame, text="Load Logo...", command=self.choose_logo_file).pack(side="left")

        # Instant Preview strip
        self.preview_fraew_label = ttk.Label(form_frame, text="Current estimate (ex VAT): –", font=("Segoe UI", 10, "bold"))
        self.preview_fraew_label.pack(anchor="w", pady=(10, 4))
        self.after(50, self._fraew_preview)

        results_frame = ttk.Frame(main)
        results_frame.pack(side="left", fill="both", expand=True, pady=6)
        ttk.Label(results_frame, text="Price Summary", font=self.label_font).pack(anchor="w", pady=(0, 6))
        self.results_text = tk.Text(results_frame, font=self.text_font, bg="white",
                                    wrap="word", state="disabled", bd=1, relief="solid")
        self.results_text.pack(fill="both", expand=True)

    # ---------- Fire Doors tab ----------
    def _build_fire_doors_tab(self, parent):
        main = ttk.Frame(parent)
        main.pack(fill="both", expand=True)

        form_frame = ttk.Frame(main)
        form_frame.pack(side="left", fill="y", padx=(0, 8), pady=6)

        ttk.Label(form_frame, text="Doors to inspect:", font=self.label_font).pack(anchor="w")
        self.doors_count_var = tk.IntVar(value=50)
        doors_count_spin = ttk.Spinbox(form_frame, from_=0, to=10000, textvariable=self.doors_count_var, width=8, font=self.text_font)
        doors_count_spin.pack(anchor="w", pady=(0, 8))
        doors_count_spin.configure(command=self._doors_preview)
        doors_count_spin.bind("<KeyRelease>", lambda e: self._doors_preview())
        self.doors_count_var.trace_add("write", self._doors_preview)

        ttk.Label(form_frame, text="Rate per door (£):", font=self.label_font).pack(anchor="w")
        self.doors_rate_var = tk.DoubleVar(value=17.50)
        doors_rate_spin = ttk.Spinbox(form_frame, from_=0, to=200, increment=0.5, textvariable=self.doors_rate_var, width=8, font=self.text_font)
        doors_rate_spin.pack(anchor="w", pady=(0, 8))
        doors_rate_spin.configure(command=self._doors_preview)
        doors_rate_spin.bind("<KeyRelease>", lambda e: self._doors_preview())
        self.doors_rate_var.trace_add("write", self._doors_preview)

        ttk.Label(form_frame, text="Complexity (1–5):", font=self.label_font).pack(anchor="w")
        self.doors_complexity_var = tk.IntVar(value=3)
        doors_cx_spin = ttk.Spinbox(form_frame, from_=1, to=5, textvariable=self.doors_complexity_var, width=5, font=self.text_font)
        doors_cx_spin.pack(anchor="w", pady=(0, 8))
        doors_cx_spin.configure(command=self._doors_preview)
        doors_cx_spin.bind("<KeyRelease>", lambda e: self._doors_preview())
        self.doors_complexity_var.trace_add("write", self._doors_preview)

        self.doors_portfolio_disc_var = tk.BooleanVar(value=False)
        doors_disc_chk = ttk.Checkbutton(form_frame, text="Apply 5% portfolio discount", variable=self.doors_portfolio_disc_var)
        doors_disc_chk.pack(anchor="w", pady=(0, 8))
        self.doors_portfolio_disc_var.trace_add("write", self._doors_preview)

        ttk.Button(form_frame, text="Compute Door Price", command=self.on_compute_doors).pack(anchor="w", pady=(6, 0))

        self.preview_doors_label = ttk.Label(form_frame, text="Current estimate (ex VAT): –", font=("Segoe UI", 10, "bold"))
        self.preview_doors_label.pack(anchor="w", pady=(10, 4))
        self.after(50, self._doors_preview)

        results_frame = ttk.Frame(main)
        results_frame.pack(side="left", fill="both", expand=True, pady=6)
        ttk.Label(results_frame, text="Fire Doors Price Summary", font=self.label_font).pack(anchor="w", pady=(0, 6))
        self.results_doors_text = tk.Text(results_frame, font=self.text_font, bg="white",
                                          wrap="word", state="disabled", bd=1, relief="solid")
        self.results_doors_text.pack(fill="both", expand=True)

    # ---------- Compartmentation tab ----------
    def _build_compartmentation_tab(self, parent):
        main = ttk.Frame(parent)
        main.pack(fill="both", expand=True)

        form_frame = ttk.Frame(main)
        form_frame.pack(side="left", fill="y", padx=(0, 8), pady=6)

        ttk.Label(form_frame, text="No. of risers/shafts:", font=self.label_font).pack(anchor="w")
        self.comp_risers_var = tk.IntVar(value=4)
        comp_risers_spin = ttk.Spinbox(form_frame, from_=0, to=200, textvariable=self.comp_risers_var, width=6, font=self.text_font)
        comp_risers_spin.pack(anchor="w", pady=(0, 8))
        comp_risers_spin.configure(command=self._comp_preview)
        comp_risers_spin.bind("<KeyRelease>", lambda e: self._comp_preview())
        self.comp_risers_var.trace_add("write", self._comp_preview)

        ttk.Label(form_frame, text="Floors to survey:", font=self.label_font).pack(anchor="w")
        self.comp_floors_var = tk.IntVar(value=8)
        comp_floors_spin = ttk.Spinbox(form_frame, from_=0, to=200, textvariable=self.comp_floors_var, width=6, font=self.text_font)
        comp_floors_spin.pack(anchor="w", pady=(0, 8))
        comp_floors_spin.configure(command=self._comp_preview)
        comp_floors_spin.bind("<KeyRelease>", lambda e: self._comp_preview())
        self.comp_floors_var.trace_add("write", self._comp_preview)

        ttk.Label(form_frame, text="Complexity (1–5):", font=self.label_font).pack(anchor="w")
        self.comp_complexity_var = tk.IntVar(value=3)
        comp_cx_spin = ttk.Spinbox(form_frame, from_=1, to=5, textvariable=self.comp_complexity_var, width=5, font=self.text_font)
        comp_cx_spin.pack(anchor="w", pady=(0, 8))
        comp_cx_spin.configure(command=self._comp_preview)
        comp_cx_spin.bind("<KeyRelease>", lambda e: self._comp_preview())
        self.comp_complexity_var.trace_add("write", self._comp_preview)

        ttk.Label(form_frame, text="Access:", font=self.label_font).pack(anchor="w")
        self.comp_access_means_var = tk.StringVar(value="MEWP")
        comp_access_combo = ttk.Combobox(form_frame, textvariable=self.comp_access_means_var,
                                         values=["MEWP", "Scaffold", "Internal only"], width=18)
        comp_access_combo.pack(anchor="w", pady=(0, 8))
        comp_access_combo.bind("<<ComboboxSelected>>", lambda e: self._comp_preview())
        self.comp_access_means_var.trace_add("write", self._comp_preview)

        ttk.Button(form_frame, text="Compute Compartmentation Price", command=self.on_compute_compartmentation)\
            .pack(anchor="w", pady=(6, 0))

        self.preview_comp_label = ttk.Label(form_frame, text="Current estimate (ex VAT): –", font=("Segoe UI", 10, "bold"))
        self.preview_comp_label.pack(anchor="w", pady=(10, 4))
        self.after(50, self._comp_preview)

        results_frame = ttk.Frame(main)
        results_frame.pack(side="left", fill="both", expand=True, pady=6)
        ttk.Label(results_frame, text="Compartmentation Price Summary", font=self.label_font)\
            .pack(anchor="w", pady=(0, 6))
        self.results_comp_text = tk.Text(results_frame, font=self.text_font, bg="white",
                                         wrap="word", state="disabled", bd=1, relief="solid")
        self.results_comp_text.pack(fill="both", expand=True)

    # ---------- Fire Strategy tab ----------
    def _build_fire_strategy_tab(self, parent):
        main = ttk.Frame(parent)
        main.pack(fill="both", expand=True)

        form = ttk.Frame(main)
        form.pack(side="left", fill="y", padx=(0, 8), pady=6)

        ttk.Label(form, text="No. of cores:", font=self.label_font).pack(anchor="w")
        self.strategy_cores_var = tk.IntVar(value=1)
        strategy_cores_spin = ttk.Spinbox(form, from_=1, to=12, textvariable=self.strategy_cores_var, width=6, font=self.text_font)
        strategy_cores_spin.pack(anchor="w", pady=(0, 8))
        strategy_cores_spin.configure(command=self._strategy_preview)
        strategy_cores_spin.bind("<KeyRelease>", lambda e: self._strategy_preview())
        self.strategy_cores_var.trace_add("write", self._strategy_preview)

        ttk.Label(form, text="Distinct flat/unit types:", font=self.label_font).pack(anchor="w")
        self.strategy_flattypes_var = tk.IntVar(value=2)
        strategy_types_spin = ttk.Spinbox(form, from_=1, to=20, textvariable=self.strategy_flattypes_var, width=6, font=self.text_font)
        strategy_types_spin.pack(anchor="w", pady=(0, 8))
        strategy_types_spin.configure(command=self._strategy_preview)
        strategy_types_spin.bind("<KeyRelease>", lambda e: self._strategy_preview())
        self.strategy_flattypes_var.trace_add("write", self._strategy_preview)

        ttk.Label(form, text="Documentation quality:", font=self.label_font).pack(anchor="w")
        self.strategy_docq_var = tk.StringVar(value="Average")
        strategy_docq_combo = ttk.Combobox(form, textvariable=self.strategy_docq_var, values=["Good", "Average", "Poor"], width=18)
        strategy_docq_combo.pack(anchor="w", pady=(0, 8))
        strategy_docq_combo.bind("<<ComboboxSelected>>", lambda e: self._strategy_preview())
        self.strategy_docq_var.trace_add("write", self._strategy_preview)

        self.strategy_siteverify_var = tk.BooleanVar(value=True)
        strategy_site_chk = ttk.Checkbutton(form, text="Include site verification visit", variable=self.strategy_siteverify_var)
        strategy_site_chk.pack(anchor="w", pady=(0, 8))
        self.strategy_siteverify_var.trace_add("write", self._strategy_preview)

        ttk.Label(form, text="Complexity (1–5):", font=self.label_font).pack(anchor="w")
        self.strategy_complexity_var = tk.IntVar(value=3)
        strategy_cx_spin = ttk.Spinbox(form, from_=1, to=5, textvariable=self.strategy_complexity_var, width=5, font=self.text_font)
        strategy_cx_spin.pack(anchor="w", pady=(0, 8))
        strategy_cx_spin.configure(command=self._strategy_preview)
        strategy_cx_spin.bind("<KeyRelease>", lambda e: self._strategy_preview())
        self.strategy_complexity_var.trace_add("write", self._strategy_preview)

        ttk.Button(form, text="Compute Fire Strategy Price", command=self.on_compute_fire_strategy)\
            .pack(anchor="w", pady=(6, 0))

        self.preview_strategy_label = ttk.Label(form, text="Current estimate (ex VAT): –", font=("Segoe UI", 10, "bold"))
        self.preview_strategy_label.pack(anchor="w", pady=(10, 4))
        self.after(50, self._strategy_preview)

        results = ttk.Frame(main)
        results.pack(side="left", fill="both", expand=True, pady=6)
        ttk.Label(results, text="Fire Strategy Price Summary", font=self.label_font).pack(anchor="w", pady=(0, 6))
        self.results_strategy_text = tk.Text(results, font=self.text_font, bg="white",
                                             wrap="word", state="disabled", bd=1, relief="solid")
        self.results_strategy_text.pack(fill="both", expand=True)

    # ---------- Safety Case tab ----------
    def _build_safety_case_tab(self, parent):
        main = ttk.Frame(parent)
        main.pack(fill="both", expand=True)

        form = ttk.Frame(main)
        form.pack(side="left", fill="y", padx=(0, 8), pady=6)

        ttk.Label(form, text="Package:", font=self.label_font).pack(anchor="w")
        self.safety_pkg_var = tk.StringVar(value="Gap Analysis")
        safety_pkg_combo = ttk.Combobox(form, textvariable=self.safety_pkg_var,
                                        values=["Gap Analysis", "Full Safety Case"], width=22)
        safety_pkg_combo.pack(anchor="w", pady=(0, 8))
        safety_pkg_combo.bind("<<ComboboxSelected>>", lambda e: self._safety_preview())
        self.safety_pkg_var.trace_add("write", self._safety_preview)

        ttk.Label(form, text="Building complexity (1–5):", font=self.label_font).pack(anchor="w")
        self.safety_complexity_var = tk.IntVar(value=3)
        safety_cx_spin = ttk.Spinbox(form, from_=1, to=5, textvariable=self.safety_complexity_var, width=5, font=self.text_font)
        safety_cx_spin.pack(anchor="w", pady=(0, 8))
        safety_cx_spin.configure(command=self._safety_preview)
        safety_cx_spin.bind("<KeyRelease>", lambda e: self._safety_preview())
        self.safety_complexity_var.trace_add("write", self._safety_preview)

        ttk.Label(form, text="Document completeness:", font=self.label_font).pack(anchor="w")
        self.safety_docs_var = tk.StringVar(value="Average")
        safety_docs_combo = ttk.Combobox(form, textvariable=self.safety_docs_var,
                                         values=["Complete", "Average", "Poor"], width=18)
        safety_docs_combo.pack(anchor="w", pady=(0, 8))
        safety_docs_combo.bind("<<ComboboxSelected>>", lambda e: self._safety_preview())
        self.safety_docs_var.trace_add("write", self._safety_preview)

        self.safety_portfolio_var = tk.BooleanVar(value=False)
        safety_port_chk = ttk.Checkbutton(form, text="Portfolio / repeat-client discount (5%)",
                                          variable=self.safety_portfolio_var)
        safety_port_chk.pack(anchor="w", pady=(0, 8))
        self.safety_portfolio_var.trace_add("write", self._safety_preview)

        ttk.Button(form, text="Compute Safety Case Price", command=self.on_compute_safety_case)\
            .pack(anchor="w", pady=(6, 0))

        self.preview_safety_label = ttk.Label(form, text="Current estimate (ex VAT): –", font=("Segoe UI", 10, "bold"))
        self.preview_safety_label.pack(anchor="w", pady=(10, 4))
        self.after(50, self._safety_preview)

        results = ttk.Frame(main)
        results.pack(side="left", fill="both", expand=True, pady=6)
        ttk.Label(results, text="Safety Case Price Summary", font=self.label_font).pack(anchor="w", pady=(0, 6))
        self.results_safety_text = tk.Text(results, font=self.text_font, bg="white",
                                           wrap="word", state="disabled", bd=1, relief="solid")
        self.results_safety_text.pack(fill="both", expand=True)

    # ---------- Logo helpers ----------
    def _try_load_image_from_base64(self, b64str: str) -> bool:
        try:
            data = base64.b64decode(b64str)
            if PIL_AVAILABLE:
                img = Image.open(io.BytesIO(data)).convert("RGBA")
                orig_w, orig_h = img.size
                scale = min(self.banner_max_w / orig_w, self.banner_max_h / orig_h, 1.0)
                new_w = max(1, int(orig_w * scale))
                new_h = max(1, int(orig_h * scale))
                img = img.resize((new_w, new_h), Image.LANCZOS)
                img_tk = ImageTk.PhotoImage(img)
                self.logo_img = img_tk
                self.logo_canvas.config(width=new_w + 12, height=new_h + 12)
                self.logo_canvas.delete("all")
                self.logo_canvas.create_image(6, 6, anchor="nw", image=self.logo_img)
                return True
            else:
                img_tk = tk.PhotoImage(data=b64str)
                self.logo_img = img_tk
                self.logo_canvas.config(width=self.logo_img.width() + 12, height=self.logo_img.height() + 12)
                self.logo_canvas.delete("all")
                self.logo_canvas.create_image(6, 6, anchor="nw", image=self.logo_img)
                return True
        except Exception as e:
            print(f"Embedded logo load failed: {e}")
            return False

    def _load_logo_if_present(self):
        script_dir = os.path.dirname(os.path.abspath(__file__)) if "__file__" in globals() else os.getcwd()
        candidates = [os.path.join(script_dir, "bn1_logo.png"), os.path.join(os.getcwd(), "bn1_logo.png")]
        for path in candidates:
            if path and os.path.isfile(path):
                if self._try_load_image_file(path):
                    return
        self._draw_fallback_logo(self.logo_canvas, self.banner_max_w, self.banner_max_h)

    def _try_load_image_file(self, path: str) -> bool:
        try:
            if PIL_AVAILABLE:
                img = Image.open(path).convert("RGBA")
                orig_w, orig_h = img.size
                scale = min(self.banner_max_w / orig_w, self.banner_max_h / orig_h, 1.0)
                new_w = max(1, int(orig_w * scale))
                new_h = max(1, int(orig_h * scale))
                img = img.resize((new_w, new_h), Image.LANCZOS)
                img_tk = ImageTk.PhotoImage(img)
                self.logo_img = img_tk
                self.logo_canvas.config(width=new_w + 12, height=new_h + 12)
                self.logo_canvas.delete("all")
                self.logo_canvas.create_image(6, 6, anchor="nw", image=self.logo_img)
                return True
            else:
                img_tk = tk.PhotoImage(file=path)
                orig_w = img_tk.width()
                orig_h = img_tk.height()
                factor = max(1, math.ceil(max(orig_w / self.banner_max_w, orig_h / self.banner_max_h)))
                if factor > 1:
                    img_tk = img_tk.subsample(factor, factor)
                self.logo_img = img_tk
                self.logo_canvas.config(width=self.logo_img.width() + 12, height=self.logo_img.height() + 12)
                self.logo_canvas.delete("all")
                self.logo_canvas.create_image(6, 6, anchor="nw", image=self.logo_img)
                return True
        except Exception as e:
            print(f"Logo load failed for {path}: {e}")
            return False

    def choose_logo_file(self):
        filetypes = [("PNG images", "*.png"), ("JPG images", "*.jpg;*.jpeg"), ("All files", "*.*")]
        path = filedialog.askopenfilename(title="Select logo image", filetypes=filetypes)
        if not path:
            return
        loaded = self._try_load_image_file(path)
        if not loaded:
            messagebox.showerror("Logo load error", f"Could not load image: {path}\nTry installing Pillow (pip install pillow) for best results.")
            self._draw_fallback_logo(self.logo_canvas, self.banner_max_w, self.banner_max_h)

    def _draw_fallback_logo(self, canvas: tk.Canvas, w: int, h: int):
        canvas.delete("all")
        canvas.configure(bg=self["bg"])
        canvas.create_rectangle(0, 0, w, h, fill="#00b7d9", outline="")
        canvas.create_text(70, h / 2 - 6, text="B", font=("Segoe UI", 48, "bold"), fill="white")
        canvas.create_text(210, h / 2 - 6, text="BN1 SURVEYORS", font=("Segoe UI", 18, "bold"), fill="white")

    # ---------- Shared results helpers ----------
    def clear_results(self):
        self._write_results("Cleared.\nFill the form and click Compute Price.")

    def _write_results(self, text: str):
        self.results_text.configure(state="normal")
        self.results_text.delete("1.0", tk.END)
        self.results_text.insert(tk.END, text)
        self.results_text.configure(state="disabled")

    # ================== INSTANT PREVIEWS ==================
    def _fraew_preview(self, *_):
        timeframe       = min(max(_get_int(self.timeframe_var, 3), 1), 5)
        cost_importance = min(max(_get_int(self.cost_importance_var, 0), -5), 5)
        ews1_required   = bool(self.ews1_var.get())
        new_client      = bool(self.new_client_var.get())
        tri_fire        = bool(self.tri_fire_var.get())
        height          = min(max(_get_float(self.height_var, 12.0), 0), 200)
        difficulty      = min(max(_get_int(self.difficulty_var, 3), 1), 5)

        timeframe_points = [0, 1, 2, 3, 5][timeframe - 1]
        cost_points = cost_importance
        new_client_points = -5 if new_client else 0
        tri_fire_points = -5 if tri_fire else 0
        difficulty_points = {1:-5, 2:-2, 3:0, 4:3, 5:5}[difficulty]

        if height < 11: baseline, ews1_addon = 6750, 0
        elif height < 18: baseline, ews1_addon = 7800, 1000
        elif height < 30: baseline, ews1_addon = 8375, 1800
        else: baseline, ews1_addon = 10050, 1800

        total_points = timeframe_points + cost_points + new_client_points + tri_fire_points + difficulty_points
        capped_pct = max(min(total_points * 0.030, 0.20), -0.20)
        adjusted = round_to_nearest_25(baseline * (1 + capped_pct))
        total = adjusted + (ews1_addon if ews1_required else 0)

        text = f"Current estimate (ex VAT): £{total:,.0f}"
        if not ews1_required and ews1_addon > 0 and height >= 11:
            text += f"    •  +£{ews1_addon:,.0f} if EWS1 added"
        if hasattr(self, "preview_fraew_label") and self.preview_fraew_label:
            self.preview_fraew_label.configure(text=text)

    def _doors_preview(self, *_):
        n = max(0, _get_int(self.doors_count_var, 50))
        rate = max(0.0, _get_float(self.doors_rate_var, 17.50))
        comp = min(max(_get_int(self.doors_complexity_var, 3), 1), 5)
        disc = bool(self.doors_portfolio_disc_var.get())

        base = n * rate
        comp_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.08, 5:0.15}[comp]
        subtotal = round_to_nearest_25(base * (1 + comp_pct))
        disc_pct = 0.05 if disc else 0.0
        total = round_to_nearest_25(subtotal * (1 - disc_pct))
        txt = f"Current estimate (ex VAT): £{total:,.0f}"
        if hasattr(self, "preview_doors_label"):
            self.preview_doors_label.configure(text=txt)

    def _comp_preview(self, *_):
        risers = max(0, _get_int(self.comp_risers_var, 4))
        floors = max(0, _get_int(self.comp_floors_var, 8))
        comp = min(max(_get_int(self.comp_complexity_var, 3), 1), 5)
        access = self.comp_access_means_var.get() or "MEWP"

        baseline = 450 * max(1, risers) + 150 * max(1, floors)
        comp_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.10, 5:0.20}[comp]
        access_pct = {"Internal only": 0.00, "MEWP": 0.07, "Scaffold": 0.15}.get(access, 0.00)
        total = round_to_nearest_25(baseline * (1 + comp_pct + access_pct))
        txt = f"Current estimate (ex VAT): £{total:,.0f}"
        if hasattr(self, "preview_comp_label"):
            self.preview_comp_label.configure(text=txt)

    def _strategy_preview(self, *_):
        cores = max(1, _get_int(self.strategy_cores_var, 1))
        flat_types = max(1, _get_int(self.strategy_flattypes_var, 2))
        docq = self.strategy_docq_var.get() or "Average"
        siteverify = bool(self.strategy_siteverify_var.get())
        cx = min(max(_get_int(self.strategy_complexity_var, 3), 1), 5)

        baseline = 4750.0
        core_add = max(0, cores - 1) * 250.0
        type_add = max(0, flat_types - 1) * 125.0
        docq_pct = {"Good": 0.00, "Average": 0.10, "Poor": 0.20}.get(docq, 0.10)
        site_pct = 0.15 if siteverify else 0.00
        cx_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.08, 5:0.15}[cx]

        subtotal = baseline + core_add + type_add
        total = round_to_nearest_25(subtotal * (1 + docq_pct + site_pct + cx_pct))
        txt = f"Current estimate (ex VAT): £{total:,.0f}"
        if hasattr(self, "preview_strategy_label"):
            self.preview_strategy_label.configure(text=txt)

    def _safety_preview(self, *_):
        pkg = self.safety_pkg_var.get() or "Gap Analysis"
        cx = min(max(_get_int(self.safety_complexity_var, 3), 1), 5)
        docs = self.safety_docs_var.get() or "Average"
        portfolio = bool(self.safety_portfolio_var.get())

        baseline = 1950.0 if pkg == "Gap Analysis" else 4275.0
        cx_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.10, 5:0.20}[cx]
        docs_pct = {"Complete": 0.00, "Average": 0.10, "Poor": 0.20}.get(docs, 0.10)
        port_pct = 0.05 if portfolio else 0.00

        subtotal = baseline * (1 + cx_pct + docs_pct)
        total = round_to_nearest_25(subtotal * (1 - port_pct))
        txt = f"Current estimate (ex VAT): £{total:,.0f}"
        if hasattr(self, "preview_safety_label"):
            self.preview_safety_label.configure(text=txt)

    # ================== COMPUTE (full breakdown + save) ==================
    def on_compute(self):
        try:
            timeframe = int(self.timeframe_var.get()); assert 1 <= timeframe <= 5
            cost_importance = int(self.cost_importance_var.get()); assert -5 <= cost_importance <= 5
            ews1_required = bool(self.ews1_var.get())
            new_client = bool(self.new_client_var.get())
            tri_fire = bool(self.tri_fire_var.get())
            height = float(self.height_var.get()); assert 0 <= height <= 200
            difficulty = int(self.difficulty_var.get()); assert 1 <= difficulty <= 5
        except Exception:
            messagebox.showwarning("Input error", "Please check FRAEW inputs.")
            return

        timeframe_points = [0, 1, 2, 3, 5][timeframe - 1]
        cost_points = cost_importance
        new_client_points = -5 if new_client else 0
        tri_fire_points = -5 if tri_fire else 0
        difficulty_points_map = {1: -5, 2: -2, 3: 0, 4: 3, 5: 5}
        difficulty_points = difficulty_points_map[difficulty]

        if height < 11:
            baseline_fee, height_band, ews1_addon = 6750, "Under 11 m", 0
        elif height < 18:
            baseline_fee, height_band, ews1_addon = 7800, "11–18 m", 1000
        elif height < 30:
            baseline_fee, height_band, ews1_addon = 8375, "18–30 m", 1800
        else:
            baseline_fee, height_band, ews1_addon = 10050, "30 m+ / 11+ storeys (Bespoke)", 1800

        total_points = timeframe_points + cost_points + new_client_points + tri_fire_points + difficulty_points
        raw_pct = total_points * 0.030
        capped_pct = max(min(raw_pct, 0.20), -0.20)
        adjusted_fee = round_to_nearest_25(baseline_fee * (1 + capped_pct))
        final_price_incl_ews1 = adjusted_fee + (ews1_addon if ews1_required else 0)

        # store last FRAEW payload for export
        self.last_fraew = {
            "tool": "FRAEW",
            "inputs": {
                "timeframe": timeframe, "cost_importance": cost_importance, "ews1_required": ews1_required,
                "new_client": new_client, "tri_fire": tri_fire, "height_m": height, "difficulty": difficulty
            },
            "totals": {
                "baseline_fee": baseline_fee, "adjusted_fee_ex_vat": adjusted_fee,
                "final_price_incl_ews1_ex_vat": final_price_incl_ews1, "height_band": height_band
            }
        }

        lines = [
            "========== BN1 PRICE SUMMARY ==========",
            f"Building height band: {height_band}",
            f"Baseline fee: £{baseline_fee:,.0f}", "",
            "Scoring (points):",
            f"  Timeframe points: {timeframe_points:+}",
            f"  Cost importance points: {cost_points:+}",
            f"  New client points: {new_client_points:+}",
            f"  Tri-Fire points: {tri_fire_points:+}",
            f"  Difficulty points: {difficulty_points:+}",
            f"→ Total points: {total_points:+.1f}", "",
            f"Raw % adjustment: {raw_pct*100:+.2f}%",
            f"Capped % adjustment (±20% limit): {capped_pct*100:+.2f}%",
            f"Final price (excl. EWS1): £{adjusted_fee:,.0f}",
        ]
        if ews1_required:
            lines.append(f"→ EWS1 required: added £{ews1_addon:,.0f} (EWS1 is not discounted)")
            lines.append(f"Final price (incl. EWS1): £{final_price_incl_ews1:,.0f}")
        else:
            lines.append("⚠️  EWS1 not included – consider upsell.")
        if tri_fire:
            lines += ["", "Tri-Fire case detected:", "⚠️ Recommend £500 peer review first; deduct £500 if FRAEW proceeds."]
        lines += ["", "All prices ex. VAT.", "", "Assumptions:", " • ±20% cap.", " • EWS1 never discounted.", " • HTTPS time-verified license.", "======================================="]

        self._write_results("\n".join(lines))
        try:
            self.clipboard_clear(); self.clipboard_append("\n".join(lines))
        except Exception: pass
        if messagebox.askyesno("Save results?", "Save this summary to a text file?"):
            self._save_summary("\n".join(lines))

    def on_compute_doors(self):
        try:
            n = int(self.doors_count_var.get())
            rate = float(self.doors_rate_var.get())
            comp = int(self.doors_complexity_var.get())  # 1..5
        except Exception:
            messagebox.showwarning("Input error", "Please check inputs for Fire Doors.")
            return
        base = n * rate
        comp_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.08, 5:0.15}[comp]
        subtotal = round_to_nearest_25(base * (1 + comp_pct))
        disc_pct = 0.05 if self.doors_portfolio_disc_var.get() else 0.0
        total = round_to_nearest_25(subtotal * (1 - disc_pct))

        self.last_doors = {
            "tool": "Fire Doors",
            "inputs": {"doors": n, "rate_per_door": rate, "complexity": comp, "portfolio_discount_5pct": bool(self.doors_portfolio_disc_var.get())},
            "totals": {"total_ex_vat": total, "complexity_pct": comp_pct, "discount_pct": disc_pct}
        }

        lines = [
            "===== FIRE DOORS PRICING =====",
            f"Door count: {n}",
            f"Rate per door: £{rate:,.2f}",
            f"Complexity adj: {comp_pct*100:+.1f}%",
        ]
        if disc_pct > 0: lines.append(f"Portfolio discount: -{disc_pct*100:.1f}%")
        lines += [f"Total (ex. VAT): £{total:,.0f}", "=============================="]
        self.results_doors_text.configure(state="normal"); self.results_doors_text.delete("1.0", tk.END)
        self.results_doors_text.insert(tk.END, "\n".join(lines)); self.results_doors_text.configure(state="disabled")

    def on_compute_compartmentation(self):
        try:
            risers = int(self.comp_risers_var.get())
            floors = int(self.comp_floors_var.get())
            comp = int(self.comp_complexity_var.get())   # 1..5
            access = self.comp_access_means_var.get()
        except Exception:
            messagebox.showwarning("Input error", "Please check inputs for Compartmentation.")
            return
        baseline = 450 * max(1, risers) + 150 * max(1, floors)
        comp_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.10, 5:0.20}[comp]
        access_pct = {"Internal only": 0.00, "MEWP": 0.07, "Scaffold": 0.15}.get(access, 0.00)
        subtotal = round_to_nearest_25(baseline * (1 + comp_pct + access_pct))

        self.last_comp = {
            "tool": "Compartmentation",
            "inputs": {"risers": risers, "floors": floors, "complexity": comp, "access": access},
            "totals": {"total_ex_vat": subtotal, "complexity_pct": comp_pct, "access_pct": access_pct}
        }

        lines = [
            "=== COMPARTMENTATION PRICING ===",
            f"Risers/shafts: {risers}",
            f"Floors: {floors}",
            f"Complexity adj: {comp_pct*100:+.1f}%",
            f"Access adj ({access}): {access_pct*100:+.1f}%",
            f"Total (ex. VAT): £{subtotal:,.0f}",
            "================================",
        ]
        self.results_comp_text.configure(state="normal"); self.results_comp_text.delete("1.0", tk.END)
        self.results_comp_text.insert(tk.END, "\n".join(lines)); self.results_comp_text.configure(state="disabled")

    def on_compute_fire_strategy(self):
        try:
            cores = int(self.strategy_cores_var.get())
            flat_types = int(self.strategy_flattypes_var.get())
            docq = self.strategy_docq_var.get()
            siteverify = bool(self.strategy_siteverify_var.get())
            cx = int(self.strategy_complexity_var.get())
        except Exception:
            messagebox.showwarning("Input error", "Please check inputs for Fire Strategy.")
            return

        baseline = 4750.0
        core_add = max(0, cores - 1) * 250.0
        type_add = max(0, flat_types - 1) * 125.0
        docq_pct = {"Good": 0.00, "Average": 0.10, "Poor": 0.20}.get(docq, 0.10)
        site_pct = 0.15 if siteverify else 0.00
        cx_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.08, 5:0.15}[cx]

        subtotal = baseline + core_add + type_add
        total = round_to_nearest_25(subtotal * (1 + docq_pct + site_pct + cx_pct))

        self.last_strategy = {
            "tool": "Fire Strategy",
            "inputs": {"cores": cores, "flat_types": flat_types, "doc_quality": docq, "site_verification": siteverify, "complexity": cx},
            "totals": {"total_ex_vat": total, "doc_quality_pct": docq_pct, "site_pct": site_pct, "complexity_pct": cx_pct,
                       "core_add": core_add, "type_add": type_add, "baseline": baseline}
        }

        lines = [
            "==== FIRE STRATEGY PRICING ====",
            f"Cores: {cores} (+£{core_add:,.0f})",
            f"Distinct unit types: {flat_types} (+£{type_add:,.0f})",
            f"Doc quality adj: {docq} ({docq_pct*100:+.1f}%)",
            f"Site verification adj: {site_pct*100:+.1f}%",
            f"Complexity adj: {cx_pct*100:+.1f}%",
            f"Total (ex. VAT): £{total:,.0f}",
            "Guide range: £4,750–£6,750 typically (varies with inputs)",
            "================================",
        ]
        self.results_strategy_text.configure(state="normal"); self.results_strategy_text.delete("1.0", tk.END)
        self.results_strategy_text.insert(tk.END, "\n".join(lines)); self.results_strategy_text.configure(state="disabled")

    def on_compute_safety_case(self):
        try:
            pkg = self.safety_pkg_var.get()
            cx = int(self.safety_complexity_var.get())
            docs = self.safety_docs_var.get()
            portfolio = bool(self.safety_portfolio_var.get())
        except Exception:
            messagebox.showwarning("Input error", "Please check inputs for Safety Case.")
            return

        baseline = 1950.0 if pkg == "Gap Analysis" else 4275.0
        cx_pct = {1:-0.05, 2:-0.02, 3:0.00, 4:0.10, 5:0.20}[cx]
        docs_pct = {"Complete": 0.00, "Average": 0.10, "Poor": 0.20}.get(docs, 0.10)
        port_pct = 0.05 if portfolio else 0.00

        subtotal = baseline * (1 + cx_pct + docs_pct)
        total = round_to_nearest_25(subtotal * (1 - port_pct))

        self.last_safety = {
            "tool": "Safety Case",
            "inputs": {"package": pkg, "complexity": cx, "docs": docs, "portfolio_discount_5pct": portfolio},
            "totals": {"total_ex_vat": total, "complexity_pct": cx_pct, "docs_pct": docs_pct, "discount_pct": port_pct,
                       "baseline": baseline}
        }

        lines = [
            "====== SAFETY CASE PRICING ======",
            f"Package: {pkg} (baseline £{baseline:,.0f})",
            f"Complexity adj: {cx_pct*100:+.1f}%",
            f"Docs completeness adj: {docs_pct*100:+.1f}%",
        ]
        if port_pct > 0: lines.append(f"Portfolio discount: -{port_pct*100:.1f}%")
        lines += [
            f"Total (ex. VAT): £{total:,.0f}",
            "Typical guide: Gap £1,950; Full £4,275 (adjusted by scope/complexity)",
            "=================================",
        ]
        self.results_safety_text.configure(state="normal"); self.results_safety_text.delete("1.0", tk.END)
        self.results_safety_text.insert(tk.END, "\n".join(lines)); self.results_safety_text.configure(state="disabled")

    # ---------- Export consolidated CSV (Desktop) ----------
    def export_consolidated_csv(self):
        try:
            import tkinter.simpledialog as simpledialog
        except Exception:
            from tkinter import simpledialog
        client_name = simpledialog.askstring("Export CSV", "Client name (required):")
        if not client_name:
            messagebox.showwarning("Export", "Client name is required.")
            return
        client_email = simpledialog.askstring("Export CSV", "Client email (optional):") or ""
        project = simpledialog.askstring("Export CSV", "Project / site (optional):") or ""
        notes = simpledialog.askstring("Export CSV", "Notes (optional):") or ""

        rows = []
        now_iso = _dt.datetime.now().isoformat(timespec="seconds")

        def mkrow(tool_name, payload):
            inputs_json = json.dumps(payload["inputs"], ensure_ascii=False, separators=(",", ":"))
            total = payload["totals"].get("total_ex_vat") \
                    or payload["totals"].get("final_price_incl_ews1_ex_vat") \
                    or payload["totals"].get("adjusted_fee_ex_vat") \
                    or payload["totals"].get("baseline") \
                    or ""
            return {
                "timestamp": now_iso,
                "tool": tool_name,
                "client_name": client_name,
                "client_email": client_email,
                "project": project,
                "inputs_json": inputs_json,
                "total_ex_vat": f"{total}",
                "notes": notes,
            }

        if self.last_fraew:      rows.append(mkrow("FRAEW", self.last_fraew))
        if self.last_doors:      rows.append(mkrow("Fire Doors", self.last_doors))
        if self.last_comp:       rows.append(mkrow("Compartmentation", self.last_comp))
        if self.last_strategy:   rows.append(mkrow("Fire Strategy", self.last_strategy))
        if self.last_safety:     rows.append(mkrow("Safety Case", self.last_safety))

        if not rows:
            messagebox.showinfo("Export", "Nothing to export yet. Compute at least one tab first.")
            return

        desktop_dir = get_desktop_dir()
        csv_path = os.path.join(desktop_dir, EXPORT_CSV)
        write_header = not os.path.isfile(csv_path)

        try:
            with open(csv_path, "a", newline="", encoding="utf-8") as f:
                writer = csv.DictWriter(f, fieldnames=[
                    "timestamp", "tool", "client_name", "client_email", "project",
                    "inputs_json", "total_ex_vat", "notes"
                ])
                if write_header:
                    writer.writeheader()
                for r in rows:
                    writer.writerow(r)
            messagebox.showinfo("Export", f"Exported {len(rows)} row(s) to your Desktop:\n{csv_path}")
        except Exception as e:
            messagebox.showerror("Export error", f"Could not write CSV:\n{e}")

    # ---------- Save ----------
    def _save_summary(self, text: str):
        path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text files", "*.txt")])
        if not path:
            return
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(text)
            messagebox.showinfo("Saved", f"Summary saved to {path}")
        except Exception as e:
            messagebox.showerror("Save error", f"Could not save file: {e}")

# ================= Main =================
if __name__ == "__main__":
    # --- License prompt with HTTPS time verification ---
    root = tk.Tk(); root.withdraw()
    try:
        import tkinter.simpledialog as simpledialog
    except Exception:
        from tkinter import simpledialog

    user_name = simpledialog.askstring("BN1 Licensing", "Enter your full name:")
    license_key = simpledialog.askstring("BN1 Licensing", "Enter your license key:")

    ok, reason = (False, "Unknown error")
    if user_name and license_key:
        ok, reason = validate_license_key_with_network_time(
            license_key, user_name, require_network_time=REQUIRE_NETWORK_TIME
        )

    if not ok:
        messagebox.showerror(
            "License Error",
            f"Invalid or expired license.\n{reason}\n\nContact Reece Angus for a renewal key."
        )
        sys.exit(1)

    root.destroy()
    # --- End license check ---

    app = BN1PricingApp()
    app.mainloop()
